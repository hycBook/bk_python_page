<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>python元编程 · Python相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="3.python协程.html" rel="next"/>
<link href="18.python_pipe包管道包学习.html" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"hycBook","repo":"bk_python_page","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
          <div class="mountain_a"></div>
          <div class="mountain_b"></div>
          <div class="house right">
            <div class="fence"></div>
            <div class="wall"></div>
            <div class="roof left"></div>
            <div class="roof right"></div>
            <div class="door"></div>
          </div>
          <div class="house left">
            <div class="fence"></div>
            <div class="wall"></div>
            <div class="roof left"></div>
            <div class="roof right"></div>
            <div class="door"></div>
          </div>
          <div class="tree_back"></div>
          <div class="tree"></div>
          <div class="postbox_a">
            <div class="hole"></div>
          </div>
          <div class="postbox_b">
            <div class="hole"></div>
          </div>
          <div class="windmill">
            <div class="tower"></div>
            <div class="t1"></div>
            <div class="t2"></div>
            <div class="blade">
              <div class="windblade"></div>
              <div class="windblade windblade2"></div>
              <div class="windblade windblade3"></div>
              <div class="windblade windblade4"></div>
            </div>
          </div>
          <div class="allsnows">
            <div class="snow1"></div>
            <div class="snow2"></div>
            <div class="snow3"></div>
            <div class="snow4"></div>
            <div class="snow5"></div>
            <div class="snow6"></div>
            <div class="snow7"></div>
            <div class="snow8"></div>
            <div class="snow9"></div>
            <div class="snow10"></div>
            <div class="snow11"></div>
            <div class="snow12"></div>
            <div class="snow13"></div>
            <div class="snow14"></div>
            <div class="snow15"></div>
            <div class="snow16"></div>
            <div class="snow17"></div>
            <div class="snow18"></div>
            <div class="snow19"></div>
            <div class="snow20"></div>
          </div>
          <div class="ground">
            <div class="g1"></div>
            <div class="g2"></div>
            <div class="g3"></div>
            <div class="ice">
              <div class="glare"></div>
              <div class="ice_shadow"></div>
            </div>

          </div>
    
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://study.hycbook.com" target="_blank">书籍主页</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../" id="chapter_id_0">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="30.Anaconda开发环境.html" id="chapter_id_1">
<a href="30.Anaconda开发环境.html">
<b>1.2.</b>
                    
                    Anaconda开发环境
            
                </a>
</li>
<li class="chapter" data-level="1.3" data-path="32.Jupyter_Notebook介绍、安装及使用教程.html" id="chapter_id_2">
<a href="32.Jupyter_Notebook介绍、安装及使用教程.html">
<b>1.3.</b>
                    
                    Jupyter_Notebook介绍、安装及使用教程
            
                </a>
</li>
<li class="chapter" data-level="1.4" data-path="15.Pythonic的几个办法.html" id="chapter_id_3">
<a href="15.Pythonic的几个办法.html">
<b>1.4.</b>
                    
                    Pythonic的几个办法
            
                </a>
</li>
<li class="chapter" data-level="1.5" data-path="19.Python增强提案PEP.html" id="chapter_id_4">
<a href="19.Python增强提案PEP.html">
<b>1.5.</b>
                    
                    Python增强提案PEP
            
                </a>
</li>
<li class="chapter" data-level="1.6" data-path="11.Regular_Expression_OP.html" id="chapter_id_5">
<a href="11.Regular_Expression_OP.html">
<b>1.6.</b>
                    
                    Regular_Expression_OP
            
                </a>
</li>
<li class="chapter" data-level="1.7" data-path="8.collections模块.html" id="chapter_id_6">
<a href="8.collections模块.html">
<b>1.7.</b>
                    
                    collections模块
            
                </a>
</li>
<li class="chapter" data-level="1.8" data-path="9.logging模块.html" id="chapter_id_7">
<a href="9.logging模块.html">
<b>1.8.</b>
                    
                    logging模块
            
                </a>
</li>
<li class="chapter" data-level="1.9" data-path="17.numpy小记.html" id="chapter_id_8">
<a href="17.numpy小记.html">
<b>1.9.</b>
                    
                    numpy小记
            
                </a>
</li>
<li class="chapter" data-level="1.10" data-path="16.pandas小记.html" id="chapter_id_9">
<a href="16.pandas小记.html">
<b>1.10.</b>
                    
                    pandas小记
            
                </a>
</li>
<li class="chapter" data-level="1.11" data-path="18.python_pipe包管道包学习.html" id="chapter_id_10">
<a href="18.python_pipe包管道包学习.html">
<b>1.11.</b>
                    
                    python_pipe包管道包学习
            
                </a>
</li>
<li class="chapter active" data-level="1.12" data-path="7.python元编程.html" id="chapter_id_11">
<a href="7.python元编程.html">
<b>1.12.</b>
                    
                    python元编程
            
                </a>
</li>
<li class="chapter" data-level="1.13" data-path="3.python协程.html" id="chapter_id_12">
<a href="3.python协程.html">
<b>1.13.</b>
                    
                    python协程
            
                </a>
</li>
<li class="chapter" data-level="1.14" data-path="14.python基础知识.html" id="chapter_id_13">
<a href="14.python基础知识.html">
<b>1.14.</b>
                    
                    python基础知识
            
                </a>
</li>
<li class="chapter" data-level="1.15" data-path="2.python多线程.html" id="chapter_id_14">
<a href="2.python多线程.html">
<b>1.15.</b>
                    
                    python多线程
            
                </a>
</li>
<li class="chapter" data-level="1.16" data-path="1.python多进程.html" id="chapter_id_15">
<a href="1.python多进程.html">
<b>1.16.</b>
                    
                    python多进程
            
                </a>
</li>
<li class="chapter" data-level="1.17" data-path="23.python常用库学习.html" id="chapter_id_16">
<a href="23.python常用库学习.html">
<b>1.17.</b>
                    
                    python常用库学习
            
                </a>
</li>
<li class="chapter" data-level="1.18" data-path="4.python异步编程.html" id="chapter_id_17">
<a href="4.python异步编程.html">
<b>1.18.</b>
                    
                    python异步编程
            
                </a>
</li>
<li class="chapter" data-level="1.19" data-path="21.python性能优化模块.html" id="chapter_id_18">
<a href="21.python性能优化模块.html">
<b>1.19.</b>
                    
                    python性能优化模块
            
                </a>
</li>
<li class="chapter" data-level="1.20" data-path="22.python网络编程.html" id="chapter_id_19">
<a href="22.python网络编程.html">
<b>1.20.</b>
                    
                    python网络编程
            
                </a>
</li>
<li class="chapter" data-level="1.21" data-path="5.python装饰器.html" id="chapter_id_20">
<a href="5.python装饰器.html">
<b>1.21.</b>
                    
                    python装饰器
            
                </a>
</li>
<li class="chapter" data-level="1.22" data-path="20.python进阶问题.html" id="chapter_id_21">
<a href="20.python进阶问题.html">
<b>1.22.</b>
                    
                    python进阶问题
            
                </a>
</li>
<li class="chapter" data-level="1.23" data-path="6.python魔法函数.html" id="chapter_id_22">
<a href="6.python魔法函数.html">
<b>1.23.</b>
                    
                    python魔法函数
            
                </a>
</li>
<li class="chapter" data-level="1.24" data-path="10.数据库相关操作.html" id="chapter_id_23">
<a href="10.数据库相关操作.html">
<b>1.24.</b>
                    
                    数据库相关操作
            
                </a>
</li>
<li class="chapter" data-level="1.25" data-path="12.文件和目录访问.html" id="chapter_id_24">
<a href="12.文件和目录访问.html">
<b>1.25.</b>
                    
                    文件和目录访问
            
                </a>
</li>
<li class="chapter" data-level="1.26" data-path="13.枚举类Enum.html" id="chapter_id_25">
<a href="13.枚举类Enum.html">
<b>1.26.</b>
                    
                    枚举类Enum
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">python元编程</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#动态属性">1 动态属性</a></li><li><span class="title-icon"></span><a href="#属性描述符getsetdelete">2 属性描述符(get/set/delete)</a></li><ul><li><span class="title-icon"></span><a href="#基本概念">2.1 基本概念</a></li><li><span class="title-icon"></span><a href="#专有名词">2.2 专有名词</a></li><li><span class="title-icon"></span><a href="#例子">2.3 例子</a></li><ul><li><span class="title-icon"></span><a href="#要点">2.3.1 要点</a></li><li><span class="title-icon"></span><a href="#模拟orm">2.3.2 模拟ORM</a></li><li><span class="title-icon"></span><a href="#成绩管理">2.3.3 成绩管理</a></li><li><span class="title-icon"></span><a href="#成绩管理20">2.3.4 成绩管理2.0</a></li><li><span class="title-icon"></span><a href="#成绩管理21">2.3.5 成绩管理2.1</a></li></ul><li><span class="title-icon"></span><a href="#进阶">2.4 进阶</a></li><ul><li><span class="title-icon"></span><a href="#添加回调">2.4.1 添加回调</a></li><li><span class="title-icon"></span><a href="#实现底层-classmethod">2.4.2 实现底层 @classmethod</a></li><li><span class="title-icon"></span><a href="#实现底层-staticmethod">2.4.3 实现底层 @staticmethod</a></li><li><span class="title-icon"></span><a href="#实现底层-property">2.4.4 实现底层 @property</a></li></ul></ul><li><span class="title-icon"></span><a href="#按需生成属性">3 按需生成属性</a></li><ul><li><span class="title-icon"></span><a href="#实例属性查找">3.1 实例属性查找</a></li><li><span class="title-icon"></span><a href="#四个魔法函数">3.2 四个魔法函数</a></li><ul><li><span class="title-icon"></span><a href="#getattr">3.2.1 __getattr__</a></li><li><span class="title-icon"></span><a href="#setattr">3.2.2 __setattr__</a></li><li><span class="title-icon"></span><a href="#delattr">3.2.3 __delattr__</a></li><li><span class="title-icon"></span><a href="#getattribute">3.2.4 __getattribute__</a></li></ul><li><span class="title-icon"></span><a href="#要点_1">3.3 要点</a></li><li><span class="title-icon"></span><a href="#例子_1">3.4 例子</a></li></ul><li><span class="title-icon"></span><a href="#元类">4 元类</a></li><ul><li><span class="title-icon"></span><a href="#基本概念_1">4.1 基本概念</a></li><ul><li><span class="title-icon"></span><a href="#元类的定义">4.1.1 元类的定义</a></li><li><span class="title-icon"></span><a href="#元类的本质">4.1.2 元类的本质</a></li><li><span class="title-icon"></span><a href="#小结">4.1.3 小结</a></li></ul><li><span class="title-icon"></span><a href="#验证子类">4.2 验证子类</a></li><li><span class="title-icon"></span><a href="#注册子类">4.3 注册子类</a></li><li><span class="title-icon"></span><a href="#获取init的默认参数">4.4 获取__init__的默认参数</a></li><li><span class="title-icon"></span><a href="#注解类的属性">4.5 注解类的属性</a></li><ul><li><span class="title-icon"></span><a href="#orm例子">4.5.1 ORM例子</a></li><li><span class="title-icon"></span><a href="#要点_2">4.5.2 要点</a></li></ul></ul></ul></div><a href="#动态属性" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><hr/>
<h1 id="动态属性">1 动态属性</h1>
<p>在 Python 中，数据的属性和处理数据的方法统称<strong>属性</strong>（attribute）。其实，方法只是<strong>可调用的</strong>属性。</p>
<h1 id="属性描述符getsetdelete">2 属性描述符(get/set/delete)</h1>
<blockquote>
<p><a href="https://halfclock.github.io/2019/06/01/python-property/" target="_blank">python 使用特性管理实例属性</a></p>
<p><a href="https://lingxiankong.github.io/2014-03-28-python-descriptor.html" target="_blank">(转)Python描述符（descriptor）解密</a></p>
<p><a href="https://www.lagou.com/lgeduarticle/9290.html" target="_blank">python理解描述符(descriptor)</a></p>
<p><a href="https://www.jianshu.com/p/fe66aebc02ec" target="_blank">python 描述符总结</a></p>
<p><a href="https://www.cnblogs.com/Jimmy1988/p/6808237.html" target="_blank">Python描述符 (descriptor) 详解</a></p>
<p><a href="https://www.coder.work/article/1262710" target="_blank">在不可散列的类中使用描述符-python</a></p>
<p><a href="https://blog.csdn.net/qq_27825451/article/details/84848341?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank">python高级编程——描述符Descriptor详解（下篇）</a></p>
</blockquote>
<h2 id="基本概念">2.1 基本概念</h2>
<font color="#D64144">描述符是对多个属性运用相同存取逻辑的一种方式。例如，Django ORM 和 SQL Alchemy 等 ORM 中的字段类型是描述符，把数据库记录中字段里的数据与 Python 对象的属性对应起来。</font>
<blockquote>
<p><strong>为什么需要描述符</strong>：对property来说，最大的缺点就是它们不能重复使用。虽然property可以让类从外部看起来接口整洁漂亮，但是却做不到内部同样整洁漂亮。</p>
<p>描述符是property的升级版，允许你为重复的property逻辑编写单独的类来处理。</p>
<p><strong>基本要求</strong>：描述符是实现了特定协议的类，这个协议包括 <code>__get__</code>、<code>__set__</code> 和 <code>__delete__</code> 方法。<code>property</code> 类实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实的代码中见到的大多数描述符只实现了 <code>__get__</code> 和 <code>__set__</code> 方法，还有很多只实现了其中的一个。</p>
<p>实现了 <code>__get__</code>、<code>__set__</code> 或 <code>__delete__</code> 方法的类是描述符。</p>
<p><strong>用法</strong>：描述符的用法是，创建一个描述符类，它的实例对象作为另一个类的属性。</p>
<p>为了让描述符能够正常工作，它们必须定义在类的层次上。如果你不这么做，那么Python无法自动为你调用<code>__get__</code>和<code>__set__</code>方法。</p>
<p><strong>大致流程</strong>：</p>
<ol>
<li>定义一个描述符类D，其内包含一个或多个<code>__get__()</code>、<code>__set__()</code>、<code>__delete__()</code>方法</li>
<li>将描述符类D的实例对象d赋值给另一个要代理的类中某个属性attr，即attr=D()</li>
<li>之后访问、赋值、删除attr属性，将会自动触发描述符类中的<code>__get__()</code>、<code>__set__()</code>、<code>__delete__()</code>方法</li>
</ol>
<p><strong>实现</strong>：</p>
<p>要定义描述符类很简单，只要某个类中包含了下面一个或多个方法，就算是满足描述符协议，就是描述符类，就可以作为属性操作的代理器。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Descriptor</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>...
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>...
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delete__</span><span class="hljs-params">(self, instance)</span>:</span>...
</code></pre>
<p>需要注意的是，<code>__get__</code>的返回值需要是属性值或抛异常，另外两个方法要返回None。</p>
<p><strong>类属性描述符对象和实例属性同名时</strong>：描述符针对的是类属性，但是当一个类中，如果类属性是描述符对象，而实例属性由于这个描述符属性同名</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
    character = CharacterDescriptor(<span class="hljs-string">'乐观的'</span>)
    weight = WeightDescriptor(<span class="hljs-number">150</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, character,weight)</span>:</span>
        self.character = character
        self.weight = weight

p = Person(<span class="hljs-string">'悲观的'</span>, <span class="hljs-number">200</span>)
print(p.character)  <span class="hljs-comment">#属性的访问</span>
print(p.weight)     <span class="hljs-comment">#</span>
</code></pre>
<p>从上面的运行结果可以看出，首先是访问了描述符的__set__方法，这是因为在构建对象的时候，相当于为character和weight赋值，然后再调用__get__方法，这是因为访问了类属性character和weight，但是最终打印出来值却并不是类属性的值，这是因为，实例属性实际上是在“描述符类属性”后面访问的，所以覆盖掉了。</p>
</blockquote>
<h2 id="专有名词">2.2 专有名词</h2>
<blockquote>
<p><strong>描述符类</strong>: <strong>实现了描述符协议的类</strong>，描述符类的一些协议(<code>__get__</code>、<code>__set__</code>或<code>__delete__</code> )。</p>
<p>实现了<code>__get__</code>、<code>__set__</code>、<code>__delete__</code> 方法的类是描述符，只要实现了其中一个就是。</p>
<p><strong>托管类</strong>： <strong>将描述符实例作为类属性的类</strong>，比如Fruits 类，他有 weight、price 两个类属性，且都被赋予了描述符类的实例。</p>
<p><strong>描述符实例</strong>: 描述符类创建出描述符实例，<strong>通常来讲，描述符类的实例会被赋给托管类的类属性。</strong></p>
<p><strong>托管实例</strong>: 托管类创建出来的实例</p>
<p><strong>托管属性</strong>: 托管类中由描述符实例处理的公开属性</p>
<p><strong>存储属性</strong>: 可以粗略的理解为、托管实例的属性、在上例中使用 <code>vars(apple)</code> 得到的结果中 price 和 weight <strong>实例属性</strong>就是存储属性，它们实际<strong>存储着*</strong><em>实例的</em><strong>*属性值</strong></p>
<p><strong>非数据描述符</strong>：一个类，如果只定义了__get__() 或者是__delete__()方法，而没有定义__set__()方法，则认为是非数据描述符(即没有定义__set__)</p>
<p><strong>数据描述符</strong>：一个类，不仅定义了__get__() 方法，还定义__set__(), __delete__() 方法，则认为是数据描述符(即定义了__get__和__set__)</p>
<p>ps： <strong>托管属性</strong>是类(Fruits)属性、存储属性是实例(apple)的属性。</p>
<p><a data-lightbox="f5d7c209-0f5d-4e1e-9c00-ec21293ad9a9" data-title="img" href="https://pic.hycbook.com/i/hexo/bk_resources/python/7.python元编程/image-20200625193223844.webp" target="_blank"><img alt="img" src="https://pic.hycbook.com/i/hexo/bk_resources/python/7.python元编程/image-20200625193223844.webp"/></a>&gt;
<code>Quantity</code> 实例是描述符，因此有个放大镜，用于获取值（<code>__get__</code>），以及一个手抓，用于设置值（<code>__set__</code>）。</p>
</blockquote>
<h2 id="例子">2.3 例子</h2>
<h3 id="要点">2.3.1 要点</h3>
<blockquote>
<p><strong>定义位置</strong>：为了让描述符能够正常工作，它们必须定义在类的层次上。如果你不这么做，那么Python无法自动为你调用__get__和__set__方法。</p>
<p><strong>独立实例</strong>：类使用了一个字典来单独保存专属于实例的数据。这个一般来说是没问题的，除非你用到了不可哈希（unhashable）的对象</p>
<p><strong>不可哈希处理</strong>：list的子类是不可哈希的，因此它们不能为描述符类用做数据字典的key。有一些方法可以规避这个问题，但是都不完美。最好的方法可能就是给你的描述符加标签了。描述符可以安全的在这里存储数据。只是要记住，不要在别的地方也给这个描述符添加标签。这样的代码很脆弱也有很多微妙之处。但这个方法的确很普遍，可以用在不可哈希的所有者类上。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Descriptor</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, label)</span>:</span>
        self.label = label

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        print(<span class="hljs-string">'__get__'</span>, instance, owner)
        <span class="hljs-keyword">return</span> instance.__dict__.get(self.label)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        print(<span class="hljs-string">'__set__'</span>)
        instance.__dict__[self.label] = value

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span><span class="hljs-params">(list)</span>:</span>
    x = Descriptor(<span class="hljs-string">'x'</span>)
    y = Descriptor(<span class="hljs-string">'y'</span>)
</code></pre>
<p><strong>泄漏内存问题</strong>：WeakKeyDictionary可以保证描述符类不会泄漏内存：WeakKeyDictionary的特殊之处在于：如果运行期系统发现这种字典所持有的引用，是整个程序里面指向Exam实例的最后一份引用，那么，系统就会自动将该实例从字典的键中移除。</p>
</blockquote>
<h3 id="模拟orm">2.3.2 模拟ORM</h3>
<font color="BA14456">代码-描述符类</font>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env Python</span>
<span class="hljs-comment"># -- coding: utf-8 --</span>
<span class="hljs-keyword">import</span> weakref
<span class="hljs-keyword">import</span> numbers

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span>:</span>
    <span class="hljs-keyword">pass</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntField</span><span class="hljs-params">(Field)</span>:</span>
    <span class="hljs-comment"># 数据描述符</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, db_column, min_value=None, max_value=None)</span>:</span>
        self.min_value = min_value
        self.max_value = max_value
        self.db_column = db_column
        <span class="hljs-keyword">if</span> min_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(min_value, numbers.Integral):
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"min_value must be int"</span>)
            <span class="hljs-keyword">elif</span> min_value &lt; <span class="hljs-number">0</span>:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"min_value must be positive int"</span>)
        <span class="hljs-keyword">if</span> max_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(max_value, numbers.Integral):
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"max_value must be int"</span>)
            <span class="hljs-keyword">elif</span> max_value &lt; <span class="hljs-number">0</span>:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"max_value must be positive int"</span>)
        <span class="hljs-keyword">if</span> min_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> max_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> min_value &gt; max_value:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"min_value must be smaller than max_value"</span>)
        self._value = weakref.WeakKeyDictionary()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">return</span> self._value.get(instance, <span class="hljs-number">0</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(value, numbers.Integral):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"int value need"</span>)
        <span class="hljs-keyword">if</span> value &lt; self.min_value <span class="hljs-keyword">or</span> value &gt; self.max_value:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"value must between min_value and max_value"</span>)
        self._value[instance] = value


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharField</span><span class="hljs-params">(Field)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, db_column, max_length=None)</span>:</span>
        <span class="hljs-comment"># self._value = None</span>
        self.db_column = db_column
        <span class="hljs-keyword">if</span> max_length <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"you must spcify max_lenth for charfiled"</span>)
        self.max_length = max_length
        self._value = weakref.WeakKeyDictionary()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">return</span> self._value.get(instance, <span class="hljs-string">'0'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(value, str):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"string value need"</span>)
        <span class="hljs-keyword">if</span> len(value) &gt; self.max_length:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"value len excess len of max_length"</span>)
        self._value[instance] = value
</code></pre>
<font color="BA14456">代码-元类</font>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMetaClass</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, name, bases, attrs, **kwargs)</span>:</span>
        <span class="hljs-keyword">if</span> name == <span class="hljs-string">"BaseModel"</span>:
            <span class="hljs-keyword">return</span> super().__new__(cls, name, bases, attrs, **kwargs)
        fields = {}
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> attrs.items():
            <span class="hljs-keyword">if</span> isinstance(value, Field):
                fields[key] = value
        attrs_meta = attrs.get(<span class="hljs-string">"Meta"</span>, <span class="hljs-keyword">None</span>)
        _meta = {}
        db_table = name.lower()
        <span class="hljs-keyword">if</span> attrs_meta <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            table = getattr(attrs_meta, <span class="hljs-string">"db_table"</span>, <span class="hljs-keyword">None</span>)
            <span class="hljs-keyword">if</span> table <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                db_table = table
        _meta[<span class="hljs-string">"db_table"</span>] = db_table
        attrs[<span class="hljs-string">"_meta"</span>] = _meta
        attrs[<span class="hljs-string">"fields"</span>] = fields
        <span class="hljs-keyword">del</span> attrs[<span class="hljs-string">"Meta"</span>]
        <span class="hljs-keyword">return</span> super().__new__(cls, name, bases, attrs, **kwargs)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseModel</span><span class="hljs-params">(metaclass=ModelMetaClass)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, *args, **kwargs)</span>:</span>
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> kwargs.items():
            setattr(self, key, value)
        <span class="hljs-keyword">return</span> super(BaseModel, self).__init__()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span><span class="hljs-params">(self)</span>:</span>
        fields = []
        values = []
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> self.fields.items():
            db_column = value.db_column
            <span class="hljs-keyword">if</span> db_column <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
                db_column = key.lower()
            fields.append(db_column)
            value = getattr(self, key)
            values.append(str(value))

        sql = <span class="hljs-string">"insert {db_table}({fields}) value({values})"</span>.format(db_table=self._meta[<span class="hljs-string">"db_table"</span>],
                                                                   fields=<span class="hljs-string">","</span>.join(fields), values=<span class="hljs-string">","</span>.join(values))
        print(sql)
</code></pre>
<font color="BA14456">代码-测试</font>
<pre><code>class User(BaseModel):
    name = CharField(db_column="name", max_length=10)
    age = IntField(db_column="age", min_value=1, max_value=100)
    class Meta:
        db_table = "user"

if __name__ == '__main__':
    first_user = User(name="bobby", age=28)
    first_user.name = "bobby"
    first_user.age = 28
    second_user = User(name="bobby", age=23)
    print(first_user.name is second_user.name)
    second_user.name = 'okay'
    print(first_user.name is second_user.name)

    second_user.name = 'sec_boddy'
    print(first_user.name)
    print(second_user.name)
    print(first_user.name is second_user.name)
</code></pre><font color="B452CD" size="4">输出</font>
<pre><code class="lang-cmd">True
False
bobby
sec_boddy
False
</code></pre>
<h3 id="成绩管理">2.3.3 成绩管理</h3>
<font color="BA14456">代码</font>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env Python</span>
<span class="hljs-comment"># -- coding: utf-8 --</span>
<span class="hljs-keyword">import</span> weakref

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grade</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self._values = weakref.WeakKeyDictionary()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">return</span> self._values.get(instance, <span class="hljs-number">0</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Grade must be between 0 and 100'</span>)
        self._values[instance] = value

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span>:</span>
    <span class="hljs-comment"># https://lingxiankong.github.io/2014-03-28-python-descriptor.html</span>
    <span class="hljs-comment"># 为了让描述符能够正常工作，它们必须定义在类的层次上。如果你不这么做，那么Python无法自动为你调用__get__和__set__方法。</span>
    <span class="hljs-comment"># 确保实例的数据只属于实例本身</span>
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    first_exam = Exam()
    first_exam.writing_grade = <span class="hljs-number">82</span>
    second_exam = Exam()
    second_exam.writing_grade = <span class="hljs-number">75</span>
    logger.info(f<span class="hljs-string">'first {first_exam.writing_grade}'</span>)
    logger.info(f<span class="hljs-string">'second {second_exam.writing_grade}'</span>)
</code></pre>
<font color="B452CD" size="4">输出</font>
<pre><code class="lang-cmd"><span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">25</span> <span class="hljs-number">20</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> lazy_db INFO:  first <span class="hljs-number">82</span>
<span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">25</span> <span class="hljs-number">20</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> lazy_db INFO:  second <span class="hljs-number">75</span>
</code></pre>
<h3 id="成绩管理20">2.3.4 成绩管理2.0</h3>
<font color="BA14456">代码</font>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grade</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
        self.name = name
        self.internal_name = <span class="hljs-string">'_'</span> + self.name

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">return</span> getattr(instance, self.internal_name, <span class="hljs-string">''</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Grade must be between 0 and 100'</span>)
        setattr(instance, self.internal_name, value)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span>:</span>
    <span class="hljs-comment"># https://lingxiankong.github.io/2014-03-28-python-descriptor.html</span>
    <span class="hljs-comment"># 为了让描述符能够正常工作，它们必须定义在类的层次上。如果你不这么做，那么Python无法自动为你调用__get__和__set__方法。</span>
    <span class="hljs-comment"># 确保实例的数据只属于实例本身</span>
    math_grade = Grade(<span class="hljs-string">'math_grade'</span>)
    writing_grade = Grade(<span class="hljs-string">'writing_grade'</span>)
    science_grade = Grade(<span class="hljs-string">'science_grade'</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    first_exam = Exam()
    first_exam.writing_grade = <span class="hljs-number">82</span>
    second_exam = Exam()
    second_exam.writing_grade = <span class="hljs-number">75</span>
    logger.info(f<span class="hljs-string">'first {first_exam.writing_grade}'</span>)
    logger.info(f<span class="hljs-string">'second {second_exam.writing_grade}'</span>)
</code></pre>
<font color="B452CD" size="4">输出</font>
<pre><code class="lang-cmd"><span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">25</span> <span class="hljs-number">20</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> lazy_db INFO:  first <span class="hljs-number">82</span>
<span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">25</span> <span class="hljs-number">20</span>:<span class="hljs-number">18</span>:<span class="hljs-number">23</span> lazy_db INFO:  second <span class="hljs-number">75</span>
</code></pre>
<h3 id="成绩管理21">2.3.5 成绩管理2.1</h3>
<font color="BA14456">代码</font>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grade</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.name = <span class="hljs-keyword">None</span>
        self.internal_name = <span class="hljs-keyword">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">return</span> getattr(instance, self.internal_name, <span class="hljs-string">''</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Grade must be between 0 and 100'</span>)
        setattr(instance, self.internal_name, value)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, name, bases, class_dict)</span>:</span>
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> class_dict.items():
            <span class="hljs-keyword">if</span> isinstance(value, Grade):
                value.name = key
                value.internal_name = <span class="hljs-string">'_'</span> + key
        cls = type.__new__(cls, name, bases, class_dict)
        <span class="hljs-keyword">return</span> cls

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span><span class="hljs-params">(object,metaclass=Meta)</span>:</span>
    <span class="hljs-comment"># https://lingxiankong.github.io/2014-03-28-python-descriptor.html</span>
    <span class="hljs-comment"># 为了让描述符能够正常工作，它们必须定义在类的层次上。如果你不这么做，那么Python无法自动为你调用__get__和__set__方法。</span>
    <span class="hljs-comment"># 确保实例的数据只属于实例本身</span>
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, writing_grade)</span>:</span>
        self.writing_grade = writing_grade

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    first_exam = Exam(<span class="hljs-number">85</span>)
    first_exam.writing_grade = <span class="hljs-number">82</span>
    second_exam = Exam(<span class="hljs-number">13</span>)
    second_exam.writing_grade = <span class="hljs-number">75</span>
    logger.info(f<span class="hljs-string">'first {first_exam.writing_grade}'</span>)
    logger.info(f<span class="hljs-string">'second {second_exam.writing_grade}'</span>)
</code></pre>
<h2 id="进阶">2.4 进阶</h2>
<h3 id="添加回调">2.4.1 添加回调</h3>
<blockquote>
<p>描述符仅仅是类，也许你想要为它们增加一些方法。举个例子，描述符是一个用来回调property的很好的手段。比如我们想要一个类的某个部分的状态发生变化时就立刻通知我们。下面的大部分代码是用来做这个的：</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackProperty</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""A property that will alert observers when upon updates"""</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, default=None)</span>:</span>
        self.data = WeakKeyDictionary()
        self.default = default
        self.callbacks = WeakKeyDictionary()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">return</span> self.data.get(instance, self.default)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>        
        <span class="hljs-keyword">for</span> callback <span class="hljs-keyword">in</span> self.callbacks.get(instance, []):
            <span class="hljs-comment"># alert callback function of new value</span>
            callback(value)
        self.data[instance] = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_callback</span><span class="hljs-params">(self, instance, callback)</span>:</span>
        <span class="hljs-string">"""Add a new function to call everytime the descriptor updates"""</span>
        <span class="hljs-comment">#but how do we get here?!?!</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.callbacks:
            self.callbacks[instance] = []
        self.callbacks[instance].append(callback)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankAccount</span><span class="hljs-params">(object)</span>:</span>
    balance = CallbackProperty(<span class="hljs-number">0</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">low_balance_warning</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">100</span>:
        <span class="hljs-keyword">print</span> <span class="hljs-string">"You are poor"</span>

ba = BankAccount()

<span class="hljs-comment"># will not work -- try it</span>
<span class="hljs-comment">#ba.balance.add_callback(ba, low_balance_warning)</span>
</code></pre>
<blockquote>
<p>这是一个很有吸引力的模式——我们可以自定义回调函数用来响应一个类中的状态变化，而且完全无需修改这个类的代码。这样做可真是替人分忧解难呀。现在，我们所要做的就是调用ba.balance.add_callback(ba, low_balance_warning)，以使得每次balance变化时low_balance_warning都会被调用。</p>
<p>但是我们是如何做到的呢？当我们试图访问它们时，描述符总是会调用<code>__get__</code>。就好像add<em>callback方法是无法触及的一样！其实关键在于利用了一种特殊的情况，即，当从类的层次访问时，`<em>_get</em></em>`方法的第一个参数是None。</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackProperty</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""A property that will alert observers when upon updates"""</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, default=None)</span>:</span>
        self.data = WeakKeyDictionary()
        self.default = default
        self.callbacks = WeakKeyDictionary()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> self        
        <span class="hljs-keyword">return</span> self.data.get(instance, self.default)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
        <span class="hljs-keyword">for</span> callback <span class="hljs-keyword">in</span> self.callbacks.get(instance, []):
            <span class="hljs-comment"># alert callback function of new value</span>
            callback(value)
        self.data[instance] = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_callback</span><span class="hljs-params">(self, instance, callback)</span>:</span>
        <span class="hljs-string">"""Add a new function to call everytime the descriptor within instance updates"""</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.callbacks:
            self.callbacks[instance] = []
        self.callbacks[instance].append(callback)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankAccount</span><span class="hljs-params">(object)</span>:</span>
    balance = CallbackProperty(<span class="hljs-number">0</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">low_balance_warning</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">100</span>:
        <span class="hljs-keyword">print</span> <span class="hljs-string">"You are now poor"</span>

ba = BankAccount()
BankAccount.balance.add_callback(ba, low_balance_warning)

ba.balance = <span class="hljs-number">5000</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"Balance is %s"</span> % ba.balance
ba.balance = <span class="hljs-number">99</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"Balance is %s"</span> % ba.balance
Balance <span class="hljs-keyword">is</span> <span class="hljs-number">5000</span>
You are now poor
Balance <span class="hljs-keyword">is</span> <span class="hljs-number">99</span>
</code></pre>
<h3 id="实现底层-classmethod">2.4.2 实现底层 @classmethod</h3>
<pre><code class="lang-python">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewDefine_classmethod</span>:</span>
    <span class="hljs-string">"""
    使用“描述符”和“装饰器”结合起来，模拟@classmethod
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, function)</span>:</span>
        self.function = function

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-comment">#对传进函数进行加工,最后返回该函数</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span>   <span class="hljs-comment">#使用不定参数是为了匹配需要修饰的函数参数</span>
            print(<span class="hljs-string">"给函数添加额外功能"</span>)
            self.function(owner, *args, **kwargs)
        <span class="hljs-keyword">return</span> wrapper

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
    name=<span class="hljs-string">'我有姓名'</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @NewDefine_classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study_1</span><span class="hljs-params">(cls)</span>:</span>
        print(f<span class="hljs-string">'我的名字是：{cls.name},我会搞学习！'</span>)

<span class="hljs-meta">    @NewDefine_classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study_2</span><span class="hljs-params">(cls,score)</span>:</span>
        print(f<span class="hljs-string">'我的名字是：{cls.name},我会搞学习！,而且这次考试考了 {score} 分'</span>)

print(Person.study_1())
print(Person.study_2(<span class="hljs-number">99</span>))
</code></pre>
<p>可以分这样几步分析：</p>
<blockquote>
<p>第一步：@NewDefine_classmethod本质上是一个“类装饰器”，从它的定义可知，它的定义为</p>
<p>class NewDefine_classmethod(function).我们发现，python系统定义的@classmethod其实它的定义也是一样的，如下，</p>
<p>class classmethod(function) .怎么样？它们二者的定义是不是一样？</p>
<p>第二步：NewDefine<em>classmethod本质上又是一个描述符，因为在它的内部实现了\</em>_get__协议，由此可见，NewDefine_classmethod是“集装饰器-描述符”于一身的。</p>
<p>第三步：运行过程分析，因为study_1=NewDefine_classmethod（study_1）,所以，study_1本质上是一个NewDefine_classmethod的对象，又因为NewDefine_classmethod本质上是实现了描述符的，所以，study_1本质上是一个定义在类中的描述符属性。</p>
<p>第四步：因为study<em>1本质上是一个定义在类中的描述符属性。所以在执行Person.study_1的时候，相当于是访问类的描述符属性，所以会进入到描述符的\</em>_get__方法。</p>
<p>现在是不是觉得原来python描述符还有这样神奇的使用呢？</p>
<p>注意：如果修饰的函数本身是具有返回值的，在__get__里面所定义的wrapper里面一定要返回，即return self.function(owner, <em>args, *</em>kwargs)。</p>
<p>还有一个地方需要注意的是，因为这是自定义的底层实现，所以一些集成IDE可能会显示有语法错误，但是这没有关系，这正是python灵活多变的地方，运行并不会出现错误。</p>
</blockquote>
<h3 id="实现底层-staticmethod">2.4.3 实现底层 @staticmethod</h3>
<p>staticmethod方法与classmethod方法的区别在于classmethod方法在使用需要传进一个类的引用作为参数。而staticmethod则不用。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewDefine_staticmethod</span>:</span>
    <span class="hljs-string">"""
    使用“描述符”和“装饰器”结合起来，模拟@classmethod
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, function)</span>:</span>
        self.function = function

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        <span class="hljs-comment">#对传进函数进行加工,最后返回该函数</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span>   <span class="hljs-comment">#使用不定参数是为了匹配需要修饰的函数参数</span>
            print(<span class="hljs-string">"给函数添加额外功能"</span>)
            self.function(*args, **kwargs)
        <span class="hljs-keyword">return</span> wrapper

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
    name=<span class="hljs-string">'我有姓名'</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @NewDefine_staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study_1</span><span class="hljs-params">(math,english)</span>:</span>
        print(f<span class="hljs-string">'我数学考了 {math} 分,英语考了 {english} 分,我会搞学习！'</span>)

<span class="hljs-meta">    @NewDefine_staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study_2</span><span class="hljs-params">(history,science)</span>:</span>
        print(f<span class="hljs-string">'我历史考了 {history} 分,科学考了 {science} 分,我会搞学习！'</span>)

print(Person.study_1(<span class="hljs-number">99</span>,<span class="hljs-number">98</span>))
print(Person.study_2(<span class="hljs-number">88</span>,<span class="hljs-number">89</span>))
</code></pre>
<p>类方法classmethod必须第一个参数是cls，这个实际上就是判断所属的那个类，因此在__get__里面的function在调用的时候，第一个参数需要传递为owner，因为所属的“类cls等价于Person等价于owner”，但是因为静态方法不需要任何参数cls或者是self都不需要，因此在__get__实现的时候不能再传递owner参数，否则会显示参数错误。</p>
<h3 id="实现底层-property">2.4.4 实现底层 @property</h3>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewDefine_property</span>:</span>
    <span class="hljs-string">"""
    使用“描述符”和“装饰器”结合起来，模拟@classmethod
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, function)</span>:</span>
        self.function = function

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
        print(<span class="hljs-string">"给函数添加额外功能"</span>)
        <span class="hljs-keyword">return</span> self.function(instance)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
    name=<span class="hljs-string">'我有姓名'</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.__study=<span class="hljs-number">100</span>

<span class="hljs-meta">    @NewDefine_property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study_1</span><span class="hljs-params">(self)</span>:</span>  <span class="hljs-comment">#使用property装饰的函数一般不要用“参数”，因为它的主要功能是对属性的封装</span>
        <span class="hljs-keyword">return</span> self.__study

p=Person()
print(p.study_1)
</code></pre>
<p>基本思想和前面分析的还是一样的，但是有几个地方有所区别，需要注意：</p>
<blockquote>
<p>第一：@property的目的是封装一个方法，是这个方法可以被当做属性访问</p>
<p>第二：调用的方式与前面有所不同，__get__里面不能再定义wrapper了，否则不会调用wrapper。得不到想要的结果，为什么呢？</p>
<p>因为调用的方式不一样，根据前面的分析，study_1的本质是描述符属性，但是前面的调用均是使用的</p>
<p>Person.study_1()或者是p.study_1()的形式，还是当成方法去使用的。但是此处不一样了，直接就是当成属性去使用，</p>
<p>p.study<em>1 ，不再是方法调用，因此wrapper函数得不到调用。所以\</em>_get__方法得到了进一步简化。</p>
</blockquote>
<h1 id="按需生成属性">3 按需生成属性</h1>
<blockquote>
<p><a href="https://blog.csdn.net/yusuiyu/article/details/87945149" target="_blank">Python 魔法方法（三） __getattr__，__setattr__， __delattr__</a></p>
<p><a href="https://blog.csdn.net/biheyu828/article/details/82794156" target="_blank">Python高级用法之动态属性</a></p>
<p>使用__getattr__、__setattr__和__getattribute__来动态生成属性</p>
<p>Python 语言提供了一些挂钩，使得开发者很容易就能编写出通用的代码，以便将多个系统黏合起来。例如，我们要把数据库的行（row）表示为 Python 对象。由于数据库有自己的一套结构（schema），也称架构、模式、纲要、概要、大纲，所以在操作与行相对应的对象时，我们必须知道这个数据库的结构。然而，把 Python 对象与数据库相连接的这些代码，却不需要知道行的结构，所以，这部分代码应该写得通用一些。</p>
<p>那么，如何实现这种通用的代码呢？普通的实例属性、@property 方法和描述符，都不能完成此功能，因为它们都必须预先定义好，而像这样的动态行为，则可以通过 Python 的__getattr__特殊方法来做。如果某个类定义了__getattr__，同时系统在该类对象的实例字典中又找不到待查询的属性，那么，系统就会调用这个方法。</p>
</blockquote>
<h2 id="实例属性查找">3.1 实例属性查找</h2>
<blockquote>
<p><a href="https://www.shuzhiduo.com/A/gVdn4oWlJW/" target="_blank">python属性查找（attribute lookup）</a></p>
<p>首先需要明白的是实例属性查找的过程：</p>
</blockquote>
<p>如果obj是某个类的实例，那么obj.name（以及等价的getattr(obj,'name')）首先调用__getattribute__。如果类定义了__getattr__方法，那么在__getattribute__抛出 AttributeError 的时候就会调用到__getattr__，而对于描述符(__get__）的调用，则是发生在__getattribute__内部的。官网文档是这么描述的</p>
<blockquote>
<p>  The implementation works through a precedence chain that gives data descriptors priority over instance variables, instance variables priority over non-data descriptors, and assigns lowest priority to <a href="https://docs.python.org/2/reference/datamodel.html#object.__getattr__" target="_blank"><code>__getattr__()</code></a> if provided.</p>
</blockquote>
<p>  obj = Clz(), 那么obj.attr 顺序如下：</p>
<blockquote>
<p>（1）如果“attr”是出现在Clz或其基类的__dict__中， 且attr是data descriptor， 那么调用其__get__方法, 否则</p>
<p>（2）如果“attr”出现在obj的__dict__中， 那么直接返回 obj.__dict__['attr']， 否则</p>
<p>（3）如果“attr”出现在Clz或其基类的__dict__中</p>
<p>（3.1）如果attr是non-data descriptor，那么调用其__get__方法， 否则</p>
<p>（3.2）返回 __dict__['attr']</p>
<p>（4）如果Clz有__getattr__方法，调用__getattr__方法，否则</p>
<p>（5）抛出AttributeError</p>
<p>程序每次访问对象的属性时，Python 系统都会调用这个特殊方法，即使属性字典里面已经有了该属性，也依然会触发 __getattribute__ 方法。这样就可以在程序每次访问属性时，检查全局事务状态。</p>
<p>按照 Python 处理缺失属性的标准流程，如果程序动态地访问了一个不应该有的属性，那么可以在 __getattr__ 和 __getattribute__ 里面抛出 AttributeError 异常。</p>
<p>实现通用的功能时，我们经常会在 Python 代码里使用内置的 hasattr 函数来判断对象是否已经拥有了相关的属性，并用内置的 __getattr__ 函数来获取属性值。这些函数会先在实例字典中搜索待查询的属性，然后再调用 __getattr__。</p>
</blockquote>
<h2 id="四个魔法函数">3.2 四个魔法函数</h2>
<blockquote>
<p><strong>访问时机</strong></p>
<p>如果某个类定义了__getattr__ ，同时系统在该类对象的实例字典中又找不到待查询的属性，那么，系统就会调用这个方法。</p>
<p>程序每次访问对象的属性时，Python 系统都会调用这个特殊方法，即使属性字典里面已经有了该属性，也依然会触发__getattribute__方法。这样就可以在程序每次访问属性</p>
<p>按照Python处理缺失属性的标准流程，如果程序动态地访问了一个不应该有的属性，那么可以在__getattr__ 和__getattribute__ 里面抛出AttributeError异常。</p>
<p>只要对实例的属性赋值，无论是直接赋值，还是通过内置的setattr函数赋值，都会触发__setattr__方法 。</p>
</blockquote>
<h3 id="getattr">3.2.1 __getattr__</h3>
<p>当我们访问一个不存在的属性的时候，会抛出异常，提示我们不存在这个属性。而这个异常就是__getattr__方法抛出的，其原因在于他是访问一个不存在的属性的最后落脚点，作为异常抛出的地方提示出错再适合不过了。</p>
<p>看例子，我们找一个存在的属性和不存在的属性。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        self.value = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, item)</span>:</span>
        <span class="hljs-keyword">print</span> <span class="hljs-string">"into __getattr__"</span>
        <span class="hljs-keyword">return</span>  <span class="hljs-string">"can not find"</span>

a = A(<span class="hljs-number">10</span>)
<span class="hljs-keyword">print</span> a.value
<span class="hljs-comment"># 10</span>
<span class="hljs-keyword">print</span> a.name
<span class="hljs-comment"># into __getattr__</span>
<span class="hljs-comment"># can not find</span>
</code></pre>
<p>可以看出，访问存在的属性时，会正常返回值，若该值不存在，则会进入最后的兜底函数__getattr__。</p>
<h3 id="setattr">3.2.2 __setattr__</h3>
<p>在对一个属性设置值的时候，会调用到这个函数，每个设置值的方式都会进入这个方法。</p>
<pre><code class="lang-PYTHON"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-keyword">print</span> <span class="hljs-string">"into __init__"</span>
        self.value = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(self, name, value)</span>:</span>
        <span class="hljs-keyword">print</span> <span class="hljs-string">"into __setattr__"</span>
        <span class="hljs-keyword">if</span> value == <span class="hljs-number">10</span>:
            <span class="hljs-keyword">print</span> <span class="hljs-string">"from __init__"</span>
        object.__setattr__(self, name, value)


a = A(<span class="hljs-number">10</span>)
<span class="hljs-comment"># into __init__</span>
<span class="hljs-comment"># into __setattr__</span>
<span class="hljs-comment"># from __init__</span>
<span class="hljs-keyword">print</span> a.value
<span class="hljs-comment"># 10</span>
a.value = <span class="hljs-number">100</span>
<span class="hljs-comment"># into __setattr__</span>
<span class="hljs-keyword">print</span> a.value
<span class="hljs-comment"># 100</span>
</code></pre>
<p>在实例化的时候，会进行初始化，在__init__里，对value的属性值进行了设置，这时候会调用__setattr__方法。</p>
<p>在对a.value重新设置值100的时候，会再次进入__setattr__方法。</p>
<p>需要注意的地方是，在重写__setattr__方法的时候千万不要重复调用造成死循环。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        self.value = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(self, name, value)</span>:</span>
        self.name = value
</code></pre>
<p>这是个死循环。当我们实例化这个类的时候，会进入__init__，然后对value进行设置值，设置值会进入__setattr__方法，而__setattr__方法里面又有一个self.name=value设置值的操作，会再次调用自身__setattr__，造成死循环。</p>
<p>除了上面调用object类的__setattr__避开死循环，还可以如下重写__setattr__避开循环。</p>
<pre><code class="lang-PYTHON"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        self.value = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(self, name, value)</span>:</span>
        self.__dict__[name] = value


a = A(<span class="hljs-number">10</span>)
<span class="hljs-keyword">print</span> a.value
<span class="hljs-comment"># 10</span>
</code></pre>
<h3 id="delattr">3.2.3 __delattr__</h3>
<p>__delattr__是个删除属性的方法</p>
<pre><code class="lang-PYTHON"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        self.value = value

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__delattr__</span><span class="hljs-params">(self, item)</span>:</span>
        object.__delattr__(self, item)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, item)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"when can not find attribute into __getattr__"</span>



a = A(<span class="hljs-number">10</span>)
<span class="hljs-keyword">print</span> a.value
<span class="hljs-comment"># 10</span>
<span class="hljs-keyword">del</span> a.value
<span class="hljs-keyword">print</span> a.value
<span class="hljs-comment"># when can not find attribute into __getattr__</span>
</code></pre>
<p>__delattr__也要避免死循环的问题，就如__setattr__一样，在重写__delattr__，避免重复调用。</p>
<h3 id="getattribute">3.2.4 __getattribute__</h3>
<blockquote>
<p>使用__getattribute__对属性的访问做额外处理</p>
<p>假设我们需要在数据库中实现事物（transaction）处理，即每次在访问属性时，需要额外调用特殊方法检查数据库中对应的行是否有效，以及相关的事务是否依然开放。此时使用__getattr__无法实现这种功能，因为第二次访问属性时，Python会直接返回上首次调用时存储在__dict__中的属性值，而不会再次调用__getattr__插寻属性的状态。此种情况下我们需要使用__getattribute__，该方法在用户每次访问属性是都会被调用。</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyDB</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.exist = <span class="hljs-number">1</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(self, item)</span>:</span>
        print(<span class="hljs-string">'__getattribute__ (%s) called'</span> % item)
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">return</span> super().__getattribute__(item)
        <span class="hljs-keyword">except</span> AttributeError:
            value = <span class="hljs-string">' '</span>.join([<span class="hljs-string">'default value: '</span>, item])
            setattr(self, item, value)
            <span class="hljs-keyword">return</span> value

data = LazyDB()
print(data.foo) <span class="hljs-comment">##每次访问类属性时都会被调用，此处是第1次调用</span>
print(data.foo) <span class="hljs-comment">##每次访问类属性时都会被调用，此处是第2次调用</span>
print(data.__dict__)  <span class="hljs-comment">##每次访问类属性时都会被调用，此处是第3次待用</span>

<span class="hljs-comment">###输出如下：</span>
__getattribute__ (foo) called
default value:  foo
__getattribute__ (foo) called
default value:  foo
__getattribute__ (__dict__) called
{<span class="hljs-string">'exist'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'foo'</span>: <span class="hljs-string">'default value:  foo'</span>}
</code></pre>
<h2 id="要点_1">3.3 要点</h2>
<blockquote>
<ul>
<li>__getattr__ 和 __setatr__，我们可以用惰性的方式来加载并保存对象的属性。</li>
<li>要理解 __getattr__ 与 __getattribute__ 的区别：前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</li>
<li>如果要在 __getattribute__ 和 __setattr__ 方法中访问实例属性，那么应该直接通过super()（也就是object类的同名方法）来做，以避免无限递归。</li>
</ul>
<p>总结：</p>
<p>（1）对于类装饰器属性，只要出现属性访问（不管是通过对象访问还是类名访问），都会优先调用装饰器的__get__方法;</p>
<p>（2）对于类装饰器属性，若出现属性修改（不管是通过对象访问还是类名访问），都会优先调用装饰器的__set__方法;</p>
<p>（3）对于类装饰器属性，若出现属性删除（不管是通过对象访问还是类名访问），都会优先调用装饰器的__delete__方法</p>
</blockquote>
<h2 id="例子_1">3.4 例子</h2>
<h1 id="元类">4 元类</h1>
<blockquote>
<p><a href="https://www.pythonf.cn/read/35687" target="_blank">第33/34条用元类核实和登记子类,3334,验证,注册</a></p>
</blockquote>
<h2 id="基本概念_1">4.1 基本概念</h2>
<blockquote>
<p>类元编程是指在运行时创建或定制类的技艺。在 Python 中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用 <code>class</code> 关键字。类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类。最后，元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新类种，例如我们见过的抽象基类。</p>
</blockquote>
<h3 id="元类的定义">4.1.1 元类的定义</h3>
<blockquote>
<p>Python定义元类时，需要从 <code>type</code>类中继承，然后重写 <code>__new__</code>方法，便可以实现意想不到的功能。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(meta,name,bases,class_dict)</span>:</span>
        <span class="hljs-comment">#...各种逻辑实现1</span>
        cls = type.__new__(meta,name,bases,class_dict)
        print(<span class="hljs-string">'当前类名'</span>,name)
        print(<span class="hljs-string">'父类'</span>,bases)
        print(<span class="hljs-string">'全部类属性'</span>,class_dict)
        <span class="hljs-comment">#...各种逻辑实现2</span>
        <span class="hljs-keyword">return</span> cls

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(object,metaclass=Meta)</span>:</span>
    stuff = <span class="hljs-number">33</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
<pre><code class="lang-cmd">当前类名 MyClass
父类 (&lt;class 'object'&gt;,)
全部类属性 {'__module__': '__main__', '__qualname__': 'MyClass', 'stuff': <span class="hljs-number">33</span>, 'foo': &lt;function MyClass.foo <span class="hljs-built_in">at</span> <span class="hljs-number">0</span>x0000019E028315E8&gt;}
</code></pre>
<p>元类可以获知那个类的名称、其所继承的父类，以及定义在class语句体中的全部类属性</p>
</blockquote>
<h3 id="元类的本质">4.1.2 元类的本质</h3>
<p>在Python当中万物皆对象，我们用 <code>class</code>关键字定义的类本身也是一个对象， <strong>负责产生该对象的类称之为元类</strong> ，元类可以简称为类的类， <strong>元类的主要目的是为了控制类的创建行为</strong> 。</p>
<ul>
<li><code>type</code>是Python的一个内建元类，用来直接控制生成类，在Python中任何 <code>class</code>定义的类其实都是 <code>type</code>类实例化的结果。</li>
<li>只有继承了 <code>type</code>类才能称之为一个元类，否则就是一个普通的自定义类，自定义元类可以控制类的产生过程，类的产生过程其实就是元类的调用过程。</li>
</ul>
<h3 id="小结">4.1.3 小结</h3>
<p>元类的各种操作可以实现类的验证和注册逻辑，均可以在元类的 <code>__new__</code>方法中实现，主要原因是当子类对象构建时，会先调用元类的 <code>__new__</code>方法，产生一个空对象，然后再调用子类的 <code>__init__</code>方法给对象属性进行赋值。</p>
<h2 id="验证子类">4.2 验证子类</h2>
<blockquote>
<p>元类是python比较高级的用法，简而言之，元类就是创建类的类。</p>
<p>而type就是一个元类，是用来创建类对象的类。</p>
<p>因此，要定义元类就要使其继承type类。</p>
<p>通常情况下，开发者在使用OOP的方式编程时，往往会用到__init__方法，即构造函数。</p>
<p>该方法会在类初始化时运行。但是我们可以将验证的时机提前，以至于提前到类创建之时，因此就会用到__new__方法。</p>
</blockquote>
<pre><code class="lang-python">class Base(type):
    def __new__(cls, name, param, dicts):
        print(cls)
        print(name)
        print(param)
        print(dicts)
        return super().__new__(cls, name, param, dicts)

class Meta(metaclass=Base):
    name = 'yang'

    def person(self):
        pass
Meta()

&lt;class '__main__.Base'&gt;
Meta
()
{'__module__': '__main__', '__qualname__': 'Meta', 'name': 'yang', 'person': &lt;function Meta.person at 0x10c6492f0&gt;}
</code></pre>
<p><strong>元类中所编写的验证逻辑，针对的是该基类的子类，而不是基类本身</strong>。</p>
<blockquote>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>当前准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。</li>
</ol>
<p><strong>案例1</strong> ：编写一个多边形类，当边数小于 <code>3</code>时，其类报错，实现其验证逻辑。</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidatePolygon</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-comment">## __new__当中放入验证逻辑</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(meta,name,bases,class_dict)</span>:</span>
        <span class="hljs-keyword">if</span> bases!=(object,): <span class="hljs-comment">##针对子类而不对基类</span>
            <span class="hljs-keyword">if</span> class_dict[<span class="hljs-string">'sides'</span>] &lt; <span class="hljs-number">3</span>:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Polygons need 3+ sides'</span>)
        <span class="hljs-keyword">return</span> type.__new__(meta,name,bases,class_dict)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polygons</span><span class="hljs-params">(object,metaclass=ValidatePolygon)</span>:</span>
    sides = <span class="hljs-keyword">None</span>

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interior_angles</span><span class="hljs-params">(cls)</span>:</span>
        <span class="hljs-keyword">return</span> (cls.sides - <span class="hljs-number">2</span>) * <span class="hljs-number">180</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span><span class="hljs-params">(Polygons)</span>:</span>
    sides = <span class="hljs-number">3</span>

<span class="hljs-comment">### 类设计报错。</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Line</span><span class="hljs-params">(Polygons)</span>:</span>
    sides = <span class="hljs-number">1</span>
</code></pre>
<h2 id="注册子类">4.3 注册子类</h2>
<p>元类还有一个用途，就是在程序中 <code>自动注册类型</code>。开发者每次从基类中继承子类时，基类的元类都可以自动运行注册代码。</p>
<blockquote>
<p><strong>案例2</strong> ：实现对象的序列化与反序列化</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-comment">###建立类名与该类对象的映射关系，维护registry字典。</span>
registry = {}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_class</span><span class="hljs-params">(target_class)</span>:</span>
    registry[target_class.__name__] = target_class

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(data)</span>:</span>
    params = json.loads(data)
    name = params[<span class="hljs-string">'class'</span>]
    target_class = registry[name]
    <span class="hljs-keyword">return</span> target_class

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(meta,name,bases,class_dict)</span>:</span>
        cls = type.__new__(meta,name,bases,class_dict)
        register_class(cls) <span class="hljs-comment">##注册子类</span>
        <span class="hljs-keyword">return</span> cls

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BetterSerializable</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,*args)</span>:</span>
        self.args = args

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> json.dumps({<span class="hljs-string">'class'</span>:self.__class__.__name__,
                            <span class="hljs-string">'args'</span>:self.args,})
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">pass</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterSerializabel</span><span class="hljs-params">(BetterSerializable,metaclass=Meta)</span>:</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>通过元类来实现类的注册，可以确保所有的子类都不会遗漏，从而避免后续的错误。</p>
<h2 id="获取init的默认参数">4.4 获取__init__的默认参数</h2>
<blockquote>
<p>获取__init__的默认参数，并在classmethod方法中为没有给定的属性赋默认值，提升代码的健壮性</p>
<p>元类定义：</p>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env Python</span>
<span class="hljs-comment"># -- coding: utf-8 --</span>

<span class="hljs-string">"""
@version: v0.1
@author: narutohyc
@file: meta_interface.py
@Description: 
@time: 2020/6/15 20:29
"""</span>
<span class="hljs-keyword">import</span> collections
<span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> (ABC,
                 abstractmethod,
                 ABCMeta)
<span class="hljs-keyword">import</span> inspect

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DicMetaClass</span><span class="hljs-params">(ABCMeta)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, name, bases, attrs, **kwargs)</span>:</span>
        <span class="hljs-keyword">if</span> name == <span class="hljs-string">'DicMeta'</span>:
            <span class="hljs-keyword">return</span> super().__new__(cls, name, bases, attrs, **kwargs)
        <span class="hljs-comment"># 获取__init__函数的 默认值</span>
        argspec = inspect.getfullargspec(attrs[<span class="hljs-string">"__init__"</span>])
        init_defaults = dict(zip(argspec.args[-len(argspec.defaults):], argspec.defaults))
        cls.__init_defaults = init_defaults
        attrs[<span class="hljs-string">'__init_defaults__'</span>] = init_defaults
        <span class="hljs-keyword">return</span> super().__new__(cls, name, bases, attrs, **kwargs)
</code></pre>
<p>抽象父类：</p>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env Python</span>
<span class="hljs-comment"># -- coding: utf-8 --</span>

<span class="hljs-string">"""
@version: v0.1
@author: narutohyc
@file: meta_interface.py
@Description: 
@time: 2020/6/15 20:29
"""</span>

<span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> (ABC,
                 abstractmethod,
                 ABCMeta)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DicMeta</span><span class="hljs-params">(ABC, metaclass=DicMetaClass)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">'''
        返回字典
        '''</span>
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_from_mapping</span><span class="hljs-params">(cls, mapping_datas)</span>:</span>
        <span class="hljs-string">'''
        用字典来构建实例对象
        '''</span>
        <span class="hljs-keyword">assert</span> isinstance(mapping_datas, collections.abc.Mapping)
        obj = cls.__new__(cls)
        [setattr(obj, k, v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> mapping_datas.items()]
        <span class="hljs-keyword">return</span> obj
</code></pre>
<p>子类实现：</p>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env Python</span>
<span class="hljs-comment"># -- coding: utf-8 --</span>

<span class="hljs-string">"""
@version: v0.1
@author: narutohyc
@file: text_meta.py
@Description: 
@time: 2020/5/22 14:55
"""</span>
<span class="hljs-keyword">from</span> augmentation.meta_class.meta_interface <span class="hljs-keyword">import</span> DicMeta
<span class="hljs-keyword">from</span> utils.utils_func <span class="hljs-keyword">import</span> gen_md5, str2bool
<span class="hljs-keyword">import</span> re

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskMeta</span><span class="hljs-params">(DicMeta)</span>:</span>
    <span class="hljs-string">'''
    数据包装类的bean结构
    '''</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, text, doc_id, sentence_id, reg_lst,
                 has_reg=True,
                 flag=None,
                 dataset=<span class="hljs-string">'train'</span>,
                 text_source=<span class="hljs-string">"primitive"</span>)</span>:</span>
        super(TaskMeta, self).__init__()
        self.text = text
        self.doc_id = doc_id
        self.sentence_id = sentence_id
        <span class="hljs-keyword">if</span> reg_lst <span class="hljs-keyword">and</span> isinstance(reg_lst[<span class="hljs-number">0</span>], list):
            reg_lst = [<span class="hljs-string">'%s %s %s'</span> % (tag, start_idx, value) <span class="hljs-keyword">for</span> tag, start_idx, value <span class="hljs-keyword">in</span> reg_lst]
        self.reg_lst = sorted(reg_lst, key=<span class="hljs-keyword">lambda</span> reg: int(re.sub(<span class="hljs-string">' +'</span>, <span class="hljs-string">' '</span>, reg).split(<span class="hljs-string">" "</span>, <span class="hljs-number">2</span>)[<span class="hljs-number">1</span>])) <span class="hljs-keyword">if</span> reg_lst <span class="hljs-keyword">else</span> []
        self.flag = list(set(i.split(<span class="hljs-string">' '</span>, <span class="hljs-number">2</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.reg_lst)) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> flag
        self.has_reg = str2bool(has_reg)
        self.dataset = dataset
        self.text_source = text_source
        self._id = gen_md5(self.text)

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_from_mapping</span><span class="hljs-params">(cls, mapping_datas)</span>:</span>
        <span class="hljs-string">'''
        用字典来构建 TaskMeta实例
        '''</span>
        obj = super(TaskMeta, cls).load_from_mapping(mapping_datas)
        obj._id = gen_md5(obj.text)
        [setattr(obj, k, v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> obj.__init_defaults__.items() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(obj, k)]
        <span class="hljs-keyword">if</span> obj.flag <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            obj.flag = list(set(i.split(<span class="hljs-string">' '</span>, <span class="hljs-number">2</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> obj.reg_lst))
        obj.has_reg = str2bool(obj.has_reg)
        <span class="hljs-keyword">return</span> obj

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">'''
        当该类没有其他多余属性时  可以直接返回self.__dict__的副本
        '''</span>
        <span class="hljs-keyword">return</span> {<span class="hljs-string">"text"</span>: self.text,
                <span class="hljs-string">"doc_id"</span>: self.doc_id,
                <span class="hljs-string">"sentence_id"</span>: self.sentence_id,
                <span class="hljs-string">"reg_lst"</span>: self.reg_lst,
                <span class="hljs-string">"flag"</span>: list(self.flag),
                <span class="hljs-string">"has_reg"</span>: self.has_reg,
                <span class="hljs-string">"dataset"</span>: self.dataset,
                <span class="hljs-string">"text_source"</span>: self.text_source,
                <span class="hljs-string">"_id"</span>: self._id}
</code></pre>
<p>测试类：</p>
<pre><code class="lang-python">task_meta_0 = TaskMeta.load_from_mapping({<span class="hljs-string">'text'</span>: <span class="hljs-string">'斯坦福大学开发的基于条件随机场的命名实体识别系统，该系统参数是基于CoNLL、MUC-6、MUC-7和ACE命名实体语料训练出来的。'</span>, 
                                          <span class="hljs-string">'doc_id'</span>: <span class="hljs-string">'id1'</span>, <span class="hljs-string">'sentence_id'</span>: <span class="hljs-string">'id1'</span>, 
                                          <span class="hljs-string">'reg_lst'</span>: [<span class="hljs-string">'学校 0 斯坦福大学'</span>, <span class="hljs-string">'标注 33 CoNLL'</span>, <span class="hljs-string">'标注 39 MUC-6'</span>, <span class="hljs-string">'标注 45 MUC-7'</span>, <span class="hljs-string">'标注 51 ACE'</span>]})
task_meta_1 = TaskMeta.load_from_mapping({<span class="hljs-string">'text'</span>: <span class="hljs-string">'斯坦福大学开发的基于条件随机场的命名实体识别系统，该系统参数是基于CoNLL、MUC-6、MUC-7和ACE命名实体语料训练出来的。'</span>, 
                                          <span class="hljs-string">'doc_id'</span>: <span class="hljs-string">'id1'</span>, <span class="hljs-string">'sentence_id'</span>: <span class="hljs-string">'id1'</span>, 
                                          <span class="hljs-string">'reg_lst'</span>: [<span class="hljs-string">'学校 0 斯坦福大学'</span>, <span class="hljs-string">'标注 33 CoNLL'</span>, <span class="hljs-string">'标注 39 MUC-6'</span>, <span class="hljs-string">'标注 45 MUC-7'</span>, <span class="hljs-string">'标注 51 ACE'</span>], 
                                          <span class="hljs-string">'flag'</span>: [<span class="hljs-string">'学校'</span>, <span class="hljs-string">'标注'</span>], <span class="hljs-string">'has_reg'</span>: <span class="hljs-keyword">True</span>, 
                                          <span class="hljs-string">'dataset'</span>: <span class="hljs-string">'train'</span>, <span class="hljs-string">'text_source'</span>: <span class="hljs-string">'primitive'</span>, <span class="hljs-string">'_id'</span>: <span class="hljs-string">'3b895befc659345be8686bd7de4d7693'</span>})
task_meta_0.to_dict == task_meta_1.to_dict
Out[<span class="hljs-number">33</span>]: <span class="hljs-keyword">True</span>
</code></pre>
<p>可以看出，task<em>meta_0和task_meta_1两者的 值是完全相同的，这里就可以做到共享\</em>_init__默认参数的效果</p>
</blockquote>
<h2 id="注解类的属性">4.5 注解类的属性</h2>
<blockquote>
<p>元类还有一个更有用处的功能，那就是可以在某个类刚定义好但是尚未使用的时候，提前修改或注解该类的属性。这种写法通常会与描述符(descriptor) 搭配起来(参见本书第31条)，令这些属性可以更加详细地了解自己在外围类中的使用方式。
例如，要定义新的类，用来表示客户数据库里的某- -行。同时，我们还希望在该类的相关属性与数据库表的每一列之间， 建立对应关系。于是，用下面这个描述符类，把属性与列名联系起来。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span>:</span>
       <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
           self.name = name
           self.internal_name = <span class="hljs-string">'_'</span> + self.name

       <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
           <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
               <span class="hljs-keyword">return</span> self
           <span class="hljs-keyword">return</span> getattr(instance, self.internal_name, <span class="hljs-string">''</span>)

       <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
           setattr(instance, self.internal_name, value)
</code></pre>
<p>由于列的名称已经保存到了Field描述符中，所以我们可以通过内置的setattr和getattr函数，把每个实例的所有状态都作为protected字段，存放在该实例的字典里面。
在本书前面的例子中，为了避免内存泄漏，我们曾经用weakref字典来构建描述符，而刚才的那段代码，目前看来，似乎要比weakref方案便捷得多。
接下来定义表示数据行的Customer类，定义该类的时候，我们要为每个类属性指定对应的列名。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span>:</span>
       first_name = Field(<span class="hljs-string">'first_name'</span>)
       last_name = Field(<span class="hljs-string">'last_name'</span>)
       prefix = Field(<span class="hljs-string">'prefix'</span>)
       suffix = Field(<span class="hljs-string">'suffix'</span>)
</code></pre>
<p>问题在于，上面这种写法显得有些重复。在Customer类的class语句体中，我们既然要将构建好的Field对象赋给Customer.first<em> name, 那为什么还要把这个字段名(本例中是'first</em> name') 再传给Field的构造器呢?
之所以还要把字段名传给Field构造器，是因为定义Customer类的时候，Python 会以从右向左的顺序解读赋值语句，这与从左至右的阅读顺序恰好相反。首先，Python 会以Field(first<em> name') 的形式来调用Field 构造器，然后，它把调用构造器所得的返回值，赋给Customer.field</em> name。 从这个顺序来看，Field 对象没有办法提前知道自己会赋给Customer类里的哪一个属性。
    为了消除这种重复代码，我们现在用元类来改写它。使用元类，就相当于直接在class语句上面放置挂钩，只要class语句体处理完毕，这个挂钩就会立刻触发。于是，我们可以借助元类，为Field描述符自动设置其Field.name和Field.internal_ name, 而不用再像刚才那样，把列的名称手工传给Field 构造器。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span><span class="hljs-params">(type)</span>:</span>
       <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(meta, name, bases, class_dict)</span>:</span>
           <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> class_dict.items():
               <span class="hljs-keyword">if</span> isinstance(value, Field):
                   value.name = key
                   value.internal_name = <span class="hljs-string">'_'</span> + key
           cls = type.__new__(meta, name, bases, class_dict)
           <span class="hljs-keyword">return</span> cls
</code></pre>
<p>下面定义一一个基类，该基类使用刚才定义好的Meta作为其元类。凡是代表数据库里面某一行的类，都应该从这个基类中继承，以确保它们能够利用元类所提供的功能:</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseRow</span><span class="hljs-params">(object, metaclass=Meta)</span>:</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>采用元类来实现这套方案时，Field 描述符类基本上是无需修改的。唯一 要调整的地方就在于:现在不需要再给构造器传人参数了，因为刚才编写的Meta.__new__ 方法会自动把相关的属性设置好。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span>:</span>
       <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
           self.name = <span class="hljs-keyword">None</span>
           self.internal_name = <span class="hljs-keyword">None</span>
</code></pre>
<p>有了元类、新的DatabaseRow基类以及新的Field描述符之后，我们在为数据行定义DatabaseRow子类时，就不用再像原来那样，编写重复的代码了。</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BetterCustomer</span><span class="hljs-params">(DatabaseRow)</span>:</span>
       first_name = Field()
       last_name = Field()
       prefix = Field()
       suffix = Field()
</code></pre>
</blockquote>
<h3 id="orm例子">4.5.1 ORM例子</h3>
<blockquote>
<p>ORM 是 python编程语言后端web框架 Django的核心思想，“Object Relational Mapping”，即对象-关系映射，简称ORM。
一个句话理解就是：创建一个实例对象，用创建它的类名当做数据表名，用创建它的类属性对应数据表的字段，当对这个实例对象操作时，能够对应MySQL语句 </p>
</blockquote>
<font color="BA14456">代码</font>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMetaclass</span><span class="hljs-params">(type)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, name, bases, attrs)</span>:</span>
        mappings = dict()
        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> attrs.items():
            <span class="hljs-keyword">if</span> isinstance(v, tuple):
                print(<span class="hljs-string">'Found mapping :%s ==&gt; %s'</span> % (k, v))
                mappings[k] = v
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> mappings.keys():
            attrs.pop(k)
        attrs[<span class="hljs-string">'__mappings__'</span>] = mappings
        attrs[<span class="hljs-string">'__table__'</span>] = name
        <span class="hljs-keyword">return</span> type.__new__(cls, name, bases, attrs)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span><span class="hljs-params">(object, metaclass=ModelMetaclass)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, **kwargs)</span>:</span>
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> kwargs.items():
            setattr(self, name, value)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span><span class="hljs-params">(self)</span>:</span>
        fields, args = [], []
        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> self.__mappings__.items():
            fields.append(v[<span class="hljs-number">0</span>])
            args.append(getattr(self, k, <span class="hljs-keyword">None</span>))
        args_temp = list()
        <span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> args:
            <span class="hljs-keyword">if</span> isinstance(temp, int):
                args_temp.append(str(temp))
            <span class="hljs-keyword">elif</span> isinstance(temp, str):
                args_temp.append(<span class="hljs-string">"""'%s'"""</span> % temp)

        sql = <span class="hljs-string">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class="hljs-string">','</span>.join(fields), <span class="hljs-string">','</span>.join(args_temp))
        print(sql)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(Model)</span>:</span>
    uid = (<span class="hljs-string">'uid'</span>, <span class="hljs-string">'int unsigned'</span>)
    name = (<span class="hljs-string">'username'</span>, <span class="hljs-string">'varchar(30)'</span>)
    email = (<span class="hljs-string">'email'</span>, <span class="hljs-string">'varchar(30)'</span>)
    password = (<span class="hljs-string">'password'</span>, <span class="hljs-string">'varchar(30)'</span>)

user = User(uid=<span class="hljs-number">1234</span>, name=<span class="hljs-string">'naruto'</span>, email=<span class="hljs-string">'1832044042@qq.mail'</span>, password=<span class="hljs-string">'hycpass'</span>)
user.save()
</code></pre>
<font color="B452CD" size="4">输出</font>
<pre><code class="lang-python">Found mapping :uid ==&gt; (<span class="hljs-string">'uid'</span>, <span class="hljs-string">'int unsigned'</span>)
Found mapping :name ==&gt; (<span class="hljs-string">'username'</span>, <span class="hljs-string">'varchar(30)'</span>)
Found mapping :email ==&gt; (<span class="hljs-string">'email'</span>, <span class="hljs-string">'varchar(30)'</span>)
Found mapping :password ==&gt; (<span class="hljs-string">'password'</span>, <span class="hljs-string">'varchar(30)'</span>)
insert into User (uid,username,email,password) values (<span class="hljs-number">1234</span>,<span class="hljs-string">'naruto'</span>,<span class="hljs-string">'1832044042@qq.mail'</span>,<span class="hljs-string">'hycpass'</span>)
</code></pre>
<h3 id="要点_2">4.5.2 要点</h3>
<blockquote>
<p>借助元类，我们可以在某个类完全定义好之前，率先修改该类的属性。</p>
<p>描述符与元类能够有效地组合起来，以便对某种行为做出修饰，或在程序运行时探查相关信息。</p>
<p>如果把元类与描述符相结合，那就可以在不使用weakref模块的前提下避免内存泄漏。</p>
</blockquote>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2021 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2023-11-23 14:34:50
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'evyLlP61gQN3G3OM2GQq1rzH-gzGzoHsz',appKey: 'utUrzoiqNaDEGlgr09JL1pXB',placeholder: '欢迎留下评论交流~',avatar: 'wavatar',meta: undefined,pageSize: 15,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: python_pipe包管道包学习" class="navigation navigation-prev" href="18.python_pipe包管道包学习.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: python协程" class="navigation navigation-next" href="3.python协程.html">
<i class="fa fa-angle-right"></i>
</a>
<script src="https://cdn.jsdelivr.net/gh/zztongtong/CDN/js/live2d.min.js"></script><div style="position:absolute; bottom:0; left:0; width:200;"><canvas height="350" id="model_1" width="200"></canvas></div></div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"python元编程","date":"2022/9/10 20:46:25","top_img":"https://pic.hycbook.com/i//hexo/post_imgs/蕾姆6.webp","cover":"https://pic.hycbook.com/i//hexo/post_cover/蕾姆6.webp","categories":["python"],"tags":["python","动态属性","属性描述符","元类"],"abbrlink":16156,"level":"1.12","depth":1,"next":{"title":"python协程","level":"1.13","depth":1,"path":"chapters/3.python协程.md","ref":"chapters/3.python协程.md","articles":[]},"previous":{"title":"python_pipe包管道包学习","level":"1.11","depth":1,"path":"chapters/18.python_pipe包管道包学习.md","ref":"chapters/18.python_pipe包管道包学习.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","search-plus","-lunr","-search","lightbox","theme-comscore","valine","pageview-count","favicon-absolute","copyright-v"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2021","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/hycBook"},"splitter":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://s2.loli.net/2022/03/23/dEYjkaSGXwe7rnu.png","alipayText":"alipay打赏","button":"欢迎打赏","title":"","wechat":"https://s2.loli.net/2022/03/23/WDiTVSamQBJdEA4.png","wechatText":"wechat打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"copyright-v":{"copyProtect":false,"enableFooter":false,"site":"https://python.hycbook.com","author":"narutohyc","website":"python元知识驿站","image":"https://s2.loli.net/2022/03/24/pbMd1BCgUNzi7mG.png"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"hycBook","repo":"bk_python_page","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"wavatar","lang":"zh-CN","pageSize":15,"placeholder":"欢迎留下评论交流~","recordIP":false,"appId":"evyLlP61gQN3G3OM2GQq1rzH-gzGzoHsz","appKey":"utUrzoiqNaDEGlgr09JL1pXB"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Python相关学习记录","language":"zh-hans","mathjax":{"forceSVG":true},"links":{"sidebar":{"书籍主页":"https://study.hycbook.com"}},"gitbook":"*","description":"记录 Python 的学习和一些技巧的使用"},"file":{"path":"chapters/7.python元编程.md","mtime":"2023-11-23T14:34:50.582Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-11-23T14:36:23.512Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
<canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script></div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-copyright-v/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
